#small worldness measusre
delta <- (cc/0.51)/(APL/1.54)
p <- 0.75
g <- erdos.renyi.game(n, p, type = c("gnp"), directed = TRUE, loops = FALSE)
#clustering coefficient
cc <- transitivity(g, type = c("global"), vids = NULL, weights = NULL, isolates = c("NaN", "zero"))
#Average shortest path
APL <- average.path.length(g, directed = TRUE)
#small worldness measusre
delta <- (cc/0.51)/(APL/1.54)
n <- 360000000
p <- 0.25
g <- erdos.renyi.game(n, p, type = c("gnp"), directed = F, loops = FALSE)
g <- erdos.renyi.game(n, p, type = c("gnp"), directed = F, loops = FALSE)
n <- 71
p <- 1
g <- erdos.renyi.game(n, p, type = c("gnp"), directed = TRUE, loops = FALSE)
cc <- transitivity(g, type = c("global"), vids = NULL, weights = NULL, isolates = c("NaN", "zero"))
APL <- average.path.length(g, directed = TRUE)
library(igprah)
library(igpraph)
library(igraph)
library(igraph)
edge_classification <- read.csv('edge_list.csv', sep = ",")
setwd("~/GitHub/SNA #2")
edge_classification <- read.csv('edge_list.csv', sep = ",")
edge_classification$X <- NULL
classified <- edge_classification[ is.na(edge_classification$reason),]
classified <- classified[c(1,2)]
unclassified <- edge_classification[ !is.na(edge_classification$reason),]
unclassified <- unclassified[c(1,2)]
graphized <- function(x){
mat <- as.matrix(get.adjacency(graph.edgelist(as.matrix(x), directed=T)))
graph <- graph.adjacency(mat,mode="directed", weighted = TRUE)
return(graph)
}
graph_classified <- graphized(classified)
graph_unclassified <- graphized(unclassified)
topo <- function(x){
nodes <- vcount(x)
edges <- ecount(x)
density <- graph.density(x, loops = T)
topo <- data.frame(nodes,edges,density)
return(topo)
}
topo_classified <- topo(graph_classified)
topo_unclassified <- topo(graph_unclassified)
View(topo_classified)
View(topo_unclassified)
hless <- edge_classification[(edge_classification$from!="h" & edge_classification$V1!="h"),]
hless_classified <- hless[ is.na(hless$reason),]
hless_classified <- hless_classified[c(1,2)]
graph_hless <- graphized(hless_classified)
topo_hless <- topo(graph_hless)
View(topo_hless)
fgn = edge.betweenness.community (g, directed = TRUE, edge.betweenness = TRUE, merges = TRUE,
bridges = TRUE, modularity = TRUE, membership = TRUE)  ## run Girvan-Newman partitioning
fgn = edge.betweenness.community (hless, directed = TRUE, edge.betweenness = TRUE, merges = TRUE,
bridges = TRUE, modularity = TRUE, membership = TRUE)  ## run Girvan-Newman partitioning
fgn = edge.betweenness.community (graph_hless, directed = TRUE, edge.betweenness = TRUE, merges = TRUE,
bridges = TRUE, modularity = TRUE, membership = TRUE)  ## run Girvan-Newman partitioning
plot(fgn, graph_hless)
plot(fgn, graph_hless)
fwt <- walktrap.community(graph_hless, steps=200,modularity=TRUE) # , labels=TRUE)  ## run random walk partitioning
plot(fwt, graph_hless)
compare(fgn, fwt, method= c("nmi"))
compare(fgn, fwt, method= c("rand"))
compare(fgn, fwt, method= c("adjusted.rand"))
girvan = data.frame(fgn$membership)
rw = data.frame(fwt$membership)
View(rw)
View(girvan)
fb <- cbindgirvan, rw)
fb <- cbind(girvan, rw)
View(fb)
View(hless)
traints = V(graph_hless)$names
traints = V(graph_hless)$name
traits = V(graph_hless)$name
fb <- cbind(traits,girvan, rw)
View(fb)
pdf("fgn.pdf")
plot(fgn, graph_hless)
dev.off()
pdf("fwt.pdf")
plot(fwt, graph_hless)
dev.off()
write.csv(hless, file = "hless.csv")
library(igraph)
}
graphized <- function(x){
mat <- as.matrix(get.adjacency(graph.edgelist(as.matrix(x), directed=T)))
graph <- graph.adjacency(mat,mode="directed", weighted = TRUE)
return(graph)
}
hless <- read.csv('hless.csv', sep = ",")
edge_classification$X <- NULL
View(hless)
hless$X <- NULL
graph_hless <- graphized(hless)
View(hless)
hless$reason <- NULL
graph_hless <- graphized(hless)
graph_hless <- graphized(hless)
fgn = edge.betweenness.community (graph_hless, directed = TRUE, edge.betweenness = TRUE, merges = TRUE,
bridges = TRUE, modularity = TRUE, membership = TRUE)  ## run Girvan-Newman partitioning
fwt <- walktrap.community(graph_hless, steps=200,modularity=TRUE) # , labels=TRUE)  ## run random walk partitioning
compare(fgn, fwt, method= c("nmi"))
compare(fgn, fwt, method= c("rand"))
compare(fgn, fwt, method= c("adjusted.rand"))
girvan = data.frame(fgn$membership)
rw = data.frame(fwt$membership)
traits = V(graph_hless)$name
fb <- cbind(traits,girvan, rw)
View(fb)
source.with.encoding('~/GitHub/SNA extra/SNA extra.R', encoding='UTF-8')
setwd("~/GitHub/SNA extra")
library(NLP)
library(tm)
greg = readLines("text.txt")
### 2. Corpus ----
doc.vec <- VectorSource(greg)
doc.corpus <- Corpus(doc.vec)
#cleaning up the text
doc.corpus <- tm_map(doc.corpus, content_transformer(tolower))
doc.corpus <- tm_map(doc.corpus, removePunctuation)
doc.corpus <- tm_map(doc.corpus, removeNumbers)
doc.corpus <- tm_map(doc.corpus, removeWords, stopwords("english"))
library(SnowballC)
doc.corpus <- tm_map(doc.corpus, stripWhitespace)
TDM <- TermDocumentMatrix(doc.corpus)
termDocMatrix <- as.matrix(TDM)
termDocMatrix[termDocMatrix>=1] <- 1
termMatrix <- termDocMatrix %*% t(termDocMatrix)
filter.on.degree <- function(matrixY, x) {
a <- as.data.frame(degree(g2))
colnames(a) <- c("deg")
a2 <- subset(a, deg > x)
a2 <- cbind(Row.Names = rownames(a2), a2)
newdata <- as.data.frame(matrixY)
newdata <- newdata[newdata$Row.Names %in% a2$Row.Names, ]
cleaned_matrix <- as.matrix(newdata)
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
newdata <- cbind(Row.Names = rownames(newdata), newdata)
newdata <- newdata2[ , which(names(newdata) %in% a2$Row.Names)]
}
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
filter.on.degree <- function(matrixY, x) {
#finding nodes name based on the required degree
a <- as.data.frame(degree(g2))
colnames(a) <- c("deg")
a2 <- subset(a, deg > x)
a2 <- cbind(Row.Names = rownames(a2), a2)
newdata <- as.data.frame(matrixY)
newdata <- cbind(Row.Names = rownames(newdata), newdata)
newdata <- newdata[newdata$Row.Names %in% a2$Row.Names, ]
newdata <- newdata2[ , which(names(newdata) %in% a2$Row.Names)]
cleaned_matrix <- as.matrix(newdata)
}
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
doc.corpus <- tm_map(doc.corpus, stemDocument)
doc.corpus <- tm_map(doc.corpus, stripWhitespace)
TDM <- TermDocumentMatrix(doc.corpus)
termDocMatrix <- as.matrix(TDM)
termDocMatrix[termDocMatrix>=1] <- 1
termMatrix <- termDocMatrix %*% t(termDocMatrix)
filter.on.degree <- function(matrixY, x) {
#finding nodes name based on the required degree
a <- as.data.frame(degree(g2))
colnames(a) <- c("deg")
a2 <- subset(a, deg > x)
a2 <- cbind(Row.Names = rownames(a2), a2)
newdata <- as.data.frame(matrixY)
newdata <- cbind(Row.Names = rownames(newdata), newdata)
newdata <- newdata[newdata$Row.Names %in% a2$Row.Names, ]
newdata <- newdata2[ , which(names(newdata) %in% a2$Row.Names)]
cleaned_matrix <- as.matrix(newdata)
}
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
cleaned.termMatrix <- termMatrix
library(igraph)
g <- graph.adjacency(cleaned.termMatrix, weighted=T, mode = "undirected")
g <- simplify(g)
V(g)$label <- V(g)$name
V(g)$degree <- degree(g)
delete.isolates <- function(graph, mode = 'all') {
isolates <- which(degree(graph, mode = mode) == 0) - 1
delete.vertices(graph, isolates)
}
g2 <- delete.isolates(g, mode = 'in')
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
filter.on.degree <- function(matrixY, x) {
#finding nodes name based on the required degree
a <- as.data.frame(degree(g2))
colnames(a) <- c("deg")
a2 <- subset(a, deg > x)
a2 <- cbind(Row.Names = rownames(a2), a2)
newdata <- as.data.frame(matrixY)
newdata <- cbind(Row.Names = rownames(newdata), newdata)
newdata <- newdata[newdata$Row.Names %in% a2$Row.Names, ]
newdata <- newdata[ , which(names(newdata) %in% a2$Row.Names)]
cleaned_matrix <- as.matrix(newdata)
}
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
g <- graph.adjacency(cleaned.termMatrix, weighted=T, mode = "undirected")
# remove loops
g <- simplify(g)
# set labels and degrees of vertices
V(g)$label <- V(g)$name
V(g)$degree <- degree(g)
g2 <- delete.isolates(g, mode = 'in')
set.seed(3952)
layout1 <- layout.fruchterman.reingold(g)
l <- layout.fruchterman.reingold(g, repulserad=vcount(g)^3,
area=vcount(g)^2.4)
V(g)$size=degree(g)/5
layout1 <- layout.fruchterman.reingold(g2)
l <- layout.fruchterman.reingold(g2, repulserad=vcount(g2)^3,
V(g2)$size=degree(g2)/5
g2 <- delete.isolates(g, mode = 'in')
g <- delete.isolates(g, mode = 'in')
set.seed(3952)
layout1 <- layout.fruchterman.reingold(g)
l <- layout.fruchterman.reingold(g, repulserad=vcount(g)^3,
area=vcount(g)^2.4)
V(g)$size=degree(g)/5
pdf("sna_words.pdf")
plot(g, layout=layout.lgl,
edge.arrow.size=.3,
vertex.shape="none",
vertex.label = ifelse(degree(g) > 1, V(g)$label, NA)
)
dev.off()
greg = readLines("text.txt")
### 2. Corpus ----
doc.vec <- VectorSource(greg)
doc.corpus <- Corpus(doc.vec)
#cleaning up the text
doc.corpus <- tm_map(doc.corpus, content_transformer(tolower))
doc.corpus <- tm_map(doc.corpus, removePunctuation)
doc.corpus <- tm_map(doc.corpus, removeNumbers)
doc.corpus <- tm_map(doc.corpus, removeWords, stopwords("english"))
#stemming & whitespace
library(SnowballC)
doc.corpus <- tm_map(doc.corpus, stemDocument)
doc.corpus <- tm_map(doc.corpus, stripWhitespace)
TDM <- TermDocumentMatrix(doc.corpus)
termDocMatrix <- as.matrix(TDM)
termDocMatrix[termDocMatrix>=1] <- 1
termMatrix <- termDocMatrix %*% t(termDocMatrix)
g <- graph.adjacency(termMatrix, weighted=T, mode = "undirected")
filter.on.degree <- function(matrixY, x) {
#finding nodes name based on the required degree
a <- as.data.frame(degree(g))
colnames(a) <- c("deg")
a2 <- subset(a, deg > x)
a2 <- cbind(Row.Names = rownames(a2), a2)
newdata <- as.data.frame(matrixY)
newdata <- cbind(Row.Names = rownames(newdata), newdata)
newdata <- newdata[newdata$Row.Names %in% a2$Row.Names, ]
newdata <- newdata2[ , which(names(newdata) %in% a2$Row.Names)]
cleaned_matrix <- as.matrix(newdata)
}
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
filter.on.degree <- function(matrixY, x) {
#finding nodes name based on the required degree
a <- as.data.frame(degree(g))
colnames(a) <- c("deg")
a2 <- subset(a, deg > x)
a2 <- cbind(Row.Names = rownames(a2), a2)
newdata <- as.data.frame(matrixY)
newdata <- cbind(Row.Names = rownames(newdata), newdata)
newdata <- newdata[newdata$Row.Names %in% a2$Row.Names, ]
newdata <- newdata[ , which(names(newdata) %in% a2$Row.Names)]
cleaned_matrix <- as.matrix(newdata)
}
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
g2 <- graph.adjacency(cleaned.termMatrix, weighted=T, mode = "undirected")
g2 <- simplify(g2)
# set labels and degrees of vertices
V(g2)$label <- V(g2)$name
V(g2)$degree <- degree(g2)
delete.isolates <- function(graph, mode = 'all') {
isolates <- which(degree(graph, mode = mode) == 0) - 1
delete.vertices(graph, isolates)
}
g2 <- delete.isolates(g2, mode = 'in')
set.seed(3952)
layout1 <- layout.fruchterman.reingold(g2)
l <- layout.fruchterman.reingold(g2, repulserad=vcount(g2)^3,
area=vcount(g2)^2.4)
V(g2)$size=degree(g2)/5
pdf("sna_words.pdf")
plot(g2, layout=layout.lgl,
edge.arrow.size=.3,
vertex.shape="none",
vertex.label = ifelse(degree(g2) > 1, V(g2)$label, NA)
)
dev.off()
pdf("sna_words.pdf")
plot(g2, layout=layout.lgl,
edge.arrow.size=.3,
vertex.shape="none",
vertex.label.cex = 0.5,
vertex.label = ifelse(degree(g2) > 1, V(g2)$label, NA)
)
dev.off()
greg = readLines("text.txt")
### 2. Corpus ----
doc.vec <- VectorSource(greg)
doc.corpus <- Corpus(doc.vec)
#cleaning up the text
doc.corpus <- tm_map(doc.corpus, content_transformer(tolower))
doc.corpus <- tm_map(doc.corpus, removePunctuation)
doc.corpus <- tm_map(doc.corpus, removeNumbers)
doc.corpus <- tm_map(doc.corpus, removeWords, stopwords("english"))
#stemming & whitespace
library(SnowballC)
doc.corpus <- tm_map(doc.corpus, stemDocument)
doc.corpus <- tm_map(doc.corpus, stripWhitespace)
# TDM
TDM <- TermDocumentMatrix(doc.corpus)
greg = readLines("text.txt")
### 2. Corpus ----
doc.vec <- VectorSource(greg)
doc.corpus <- Corpus(doc.vec)
doc.corpus <- tm_map(doc.corpus, content_transformer(tolower))
doc.corpus <- tm_map(doc.corpus, removePunctuation)
doc.corpus <- tm_map(doc.corpus, removeNumbers)
doc.corpus <- tm_map(doc.corpus, removeWords, stopwords("english"))
doc.corpus <- tm_map(doc.corpus, stripWhitespace)
TDM <- TermDocumentMatrix(doc.corpus)
termDocMatrix <- as.matrix(TDM)
termDocMatrix[termDocMatrix>=1] <- 1
termMatrix <- termDocMatrix %*% t(termDocMatrix)
g <- graph.adjacency(termMatrix, weighted=T, mode = "undirected")
filter.on.degree <- function(matrixY, x) {
#finding nodes name based on the required degree
a <- as.data.frame(degree(g))
colnames(a) <- c("deg")
a2 <- subset(a, deg > x)
newdata <- as.data.frame(matrixY)
newdata <- newdata[newdata$Row.Names %in% a2$Row.Names, ]
cleaned_matrix <- as.matrix(newdata)
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
g2 <- simplify(g2)
V(g2)$degree <- degree(g2)
isolates <- which(degree(graph, mode = mode) == 0) - 1
}
set.seed(3952)
l <- layout.fruchterman.reingold(g2, repulserad=vcount(g2)^3,
V(g2)$size=degree(g2)/5
plot(g2, layout=layout.lgl,
vertex.shape="none",
vertex.label = ifelse(degree(g2) > 1, V(g2)$label, NA)
dev.off()
newdata <- cbind(Row.Names = rownames(newdata), newdata)
}
delete.vertices(graph, isolates)
V(g2)$label <- V(g2)$name
layout1 <- layout.fruchterman.reingold(g2)
pdf("sna_words.pdf")
vertex.label.cex = 0.5,
a2 <- cbind(Row.Names = rownames(a2), a2)
newdata <- newdata[ , which(names(newdata) %in% a2$Row.Names)]
delete.isolates <- function(graph, mode = 'all') {
area=vcount(g2)^2.4)
)
g2 <- delete.isolates(g2, mode = 'in')
g2 <- graph.adjacency(cleaned.termMatrix, weighted=T, mode = "undirected")
edge.arrow.size=.3,
greg = readLines("text.txt")
doc.vec <- VectorSource(greg)
doc.corpus <- Corpus(doc.vec)
doc.corpus <- tm_map(doc.corpus, content_transformer(tolower))
doc.corpus <- tm_map(doc.corpus, removePunctuation)
doc.corpus <- tm_map(doc.corpus, removeNumbers)
doc.corpus <- tm_map(doc.corpus, removeWords, stopwords("english"))
doc.corpus <- tm_map(doc.corpus, stripWhitespace)
TDM <- TermDocumentMatrix(doc.corpus)
termDocMatrix <- as.matrix(TDM)
termDocMatrix[termDocMatrix>=1] <- 1
termMatrix <- termDocMatrix %*% t(termDocMatrix)
g <- graph.adjacency(termMatrix, weighted=T, mode = "undirected")
#subsetting based on degree - by providing matrix and required degree
filter.on.degree <- function(matrixY, x) {
#finding nodes name based on the required degree
a <- as.data.frame(degree(g))
colnames(a) <- c("deg")
a2 <- subset(a, deg > x)
a2 <- cbind(Row.Names = rownames(a2), a2)
newdata <- as.data.frame(matrixY)
newdata <- cbind(Row.Names = rownames(newdata), newdata)
newdata <- newdata[newdata$Row.Names %in% a2$Row.Names, ]
newdata <- newdata[ , which(names(newdata) %in% a2$Row.Names)]
cleaned_matrix <- as.matrix(newdata)
}
cleaned.termMatrix <- filter.on.degree(termMatrix, 100)
g2 <- graph.adjacency(cleaned.termMatrix, weighted=T, mode = "undirected")
g2 <- simplify(g2)
# set labels and degrees of vertices
V(g2)$label <- V(g2)$name
V(g2)$degree <- degree(g2)
#delete isolates
delete.isolates <- function(graph, mode = 'all') {
isolates <- which(degree(graph, mode = mode) == 0) - 1
delete.vertices(graph, isolates)
}
g2 <- delete.isolates(g2, mode = 'in')
### 4.Plot a Graph----
# set seed to make the layout reproducible
set.seed(3952)
layout1 <- layout.fruchterman.reingold(g2)
l <- layout.fruchterman.reingold(g2, repulserad=vcount(g2)^3,
area=vcount(g2)^2.4)
V(g2)$size=degree(g2)/5
pdf("sna_words.pdf")
plot(g2, layout=layout.lgl,
edge.arrow.size=0.3,
vertex.shape="none",
vertex.label.cex = 0.5,
vertex.label = ifelse(degree(g2) > 1, V(g2)$label, NA)
)
dev.off()
layout1 <- layout.fruchterman.reingold(g2)*5
pdf("sna_words.pdf")
plot(g2, layout=layout.lgl*5,
edge.arrow.size=0.3,
vertex.shape="none",
vertex.label.cex = 0.5,
vertex.label = ifelse(degree(g2) > 1, V(g2)$label, NA)
)
dev.off()
pdf("sna_words.pdf")
plot(g2, layout=layout1,
edge.arrow.size=0.3,
vertex.shape="none",
vertex.label.cex = 0.5,
vertex.label = ifelse(degree(g2) > 1, V(g2)$label, NA)
)
dev.off()
layout1 <- layout.fruchterman.reingold(g2)*50
pdf("sna_words.pdf")
plot(g2, layout=layout1,
edge.arrow.size=0.3,
vertex.shape="none",
vertex.label.cex = 0.5,
vertex.label = ifelse(degree(g2) > 1, V(g2)$label, NA)
)
dev.off()
pdf("sna_words2.pdf")
plot(g2, layout=layout.lgl,
edge.arrow.size=0.3,
vertex.shape="none",
vertex.label.cex = 0.5,
vertex.label = ifelse(degree(g2) > 1, V(g2)$label, NA)
)
dev.off()
E(g2)$color <- "white"
pdf("sna_words1.pdf")
plot(g2, layout=layout.lgl,
edge.arrow.size=0.3,
vertex.shape="none",
vertex.label.cex = 0.5,
vertex.label = ifelse(degree(g2) > 1, V(g2)$label, NA)
)
dev.off()
View(cleaned.termMatrix)
traits <- row.names(cleaned.termMatrix)
fgn = edge.betweenness.community (g2, directed = F, edge.betweenness = TRUE, merges = TRUE,
bridges = TRUE, modularity = TRUE, membership = TRUE)  ## run Girvan-Newman partitioning
topo <- function(x){
nodes <- vcount(x)
edges <- ecount(x)
density <- graph.density(x, loops = T)
topo <- data.frame(nodes,edges,density)
return(topo)
}
topo(g2)
plot(fgn, g2)  ## plot G-N partitioning
fgn
plot(g2, fgn)  ## plot G-N partitioning
plot(fgn, g2)  ## plot G-N partitioning
pdf("fgn.pdf")
plot(fgn, g2)  ## plot G-N partitioning
dev.off()
pdf("fgn.pdf")
plot(fgn, g2
edge.arrow.size=0.3,
vertex.shape="none",
vertex.label.cex = 0.5,
vertex.label = ifelse(degree(g2) > 1, V(g2)$label, NA)
)## plot G-N partitioning
pdf("fgn.pdf")
plot(fgn, g2)
dev.off()
fwt <- walktrap.community(g2, steps=200,modularity=TRUE) # , labels=TRUE)  ## run random walk partitioning
pdf("fwt.pdf")
plot(fwt, fmg)  ## plot R-W partitioning
dev.off()
pdf("fwt.pdf")
plot(fwt, g2)  ## plot R-W partitioning
dev.off()
compare(fgn, fwt, method= c("nmi"))
compare(fgn, fwt, method= c("rand"))
compare(fgn, fwt, method= c("adjusted.rand"))
girvan = data.frame(fgn$membership)
rw = data.frame(fwt$membership)
traits <- row.names(cleaned.termMatrix)
fb <- cbind(traits, girvan, rw)
View(fb)
